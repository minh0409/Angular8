import { Component, Input, ViewChild, ElementRef, Renderer2, NgZone, Output, EventEmitter, HostBinding, forwardRef, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { parseColor, getHSV, getColorFromHSV, getColorFromHue } from './utils';
import { isPresent, fitIntoBounds } from '../common/utils';
import { isChanged } from '../common/changes';
import { containsFocus, isUntouched, isDocumentAvailable } from '../common/dom-utils';
const DEFAULT_OUTPUT_FORMAT = 'rgba';
const DEFAULT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';
const DEFAULT_SELECTED_COLOR = 'rgba(255, 255, 255, 1)';
/**
 * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.
 * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
export class ColorGradientComponent {
    constructor(host, ngZone, renderer, cdr) {
        this.host = host;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.hostClasses = true;
        /**
         * Defines whether the alpha slider will be displayed.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorGradient.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorGradient.
         */
        this.readonly = false;
        /**
         * Fires each time the user selects a new color.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.backgroundColor = DEFAULT_BACKGROUND_COLOR;
        /**
         * @hidden
         *
         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
         * updated on moving the drag handle or the sliders.
         */
        this.hsva = {};
        this._tabindex = 0;
        this.listeners = [];
        // TODO: expose as a public input prop if we can hide the opacity related slider & input
        this.format = DEFAULT_OUTPUT_FORMAT;
        this.notifyNgChanged = () => { };
        this.notifyNgTouched = () => { };
    }
    get disabledClass() {
        return this.disabled;
    }
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor(value, this.format);
    }
    get value() {
        return this._value || parseColor(DEFAULT_SELECTED_COLOR, this.format);
    }
    /**
     * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorGradient or any of its content is focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
    }
    /**
     * @hidden
     */
    get alphaSliderValue() {
        return isPresent(this.hsva.a) ? this.hsva.a * 100 : 100;
    }
    get gradientRect() {
        return this.gradientWrapper.nativeElement.getBoundingClientRect();
    }
    ngAfterViewInit() {
        this.updateUI();
        this.cdr.detectChanges();
        this.addEventListeners();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes) && !this.isFocused) {
            this.updateUI();
        }
    }
    ngOnDestroy() {
        this.listeners.forEach(removeListener => removeListener());
    }
    /**
     * Focuses the component.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {
            return;
        }
        this.focus();
        args.originalEvent.preventDefault();
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.changePosition(args);
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
    }
    /**
     * @hidden
     */
    changePosition(position) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.ngZone.run(() => this.moveDragHandle(position));
    }
    /**
     * @hidden
     */
    handleHueSliderChange(hue) {
        this.handleValueChange(getColorFromHSV(this.hsva));
        this.backgroundColor = getColorFromHue(hue);
        this.setAlphaSliderBackground(this.backgroundColor);
    }
    /**
     * @hidden
     */
    handleAlphaSliderChange(alpha) {
        this.hsva.a = alpha / 100;
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    handleInputsValueChange(color) {
        const parsed = parseColor(color, this.format);
        if (this.value !== parsed) {
            this.handleValueChange(parsed);
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        if (isPresent(this.gradientWrapper)) {
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    moveDragHandle(position) {
        const deltaX = position.clientX - this.gradientRect.left;
        const deltaY = position.clientY - this.gradientRect.top;
        const top = fitIntoBounds(deltaY, 0, this.gradientRect.height);
        const left = fitIntoBounds(deltaX, 0, this.gradientRect.width);
        this.setDragHandleElementPosition(top, left);
        this.hsva.s = left / this.gradientRect.width;
        this.hsva.v = 1 - top / this.gradientRect.height;
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    updateUI() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.hsva = getHSV(this.value);
        const top = (1 - this.hsva.v) * this.gradientRect.height;
        const left = this.hsva.s * this.gradientRect.width;
        this.setDragHandleElementPosition(top, left);
        this.backgroundColor = getColorFromHue(this.hsva.h);
        this.setAlphaSliderBackground(this.backgroundColor);
    }
    handleValueChange(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
    }
    setDragHandleElementPosition(top, left) {
        const dragHandle = this.dragHandle.nativeElement;
        this.renderer.setStyle(dragHandle, 'top', `${top}px`);
        this.renderer.setStyle(dragHandle, 'left', `${left}px`);
    }
    setAlphaSliderBackground(backgroundColor) {
        if (!isPresent(this.alphaSlider)) {
            return;
        }
        const sliderTrack = this.alphaSlider.track.nativeElement;
        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);
    }
    addEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {
                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
                    this.ngZone.run(() => this.notifyNgTouched());
                }
            });
            this.listeners.push(focusOutListener);
        });
    }
}
ColorGradientComponent.decorators = [
    { type: Component, args: [{
                selector: 'kendo-colorgradient',
                providers: [{
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ColorGradientComponent) // tslint:disable-line:no-forward-ref
                    }],
                template: `
        <div class="k-hsv-wrap k-horizontal">
            <div class="k-hsv-rectangle" [style.background-color]="backgroundColor">
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()">
                    <div
                        #dragHandle
                        class="k-draghandle"
                    >
                    </div>
                </div>
            </div>
            <kendo-slider
                class="k-hue-slider"
                [disabled]="disabled"
                [readonly]="readonly"
                [showButtons]="false"
                [tickPlacement]="'none'"
                [vertical]="true"
                [min]="0"
                [max]="360"
                [smallStep]="5"
                [largeStep]="10"
                [(value)]="hsva.h"
                (valueChange)="handleHueSliderChange($event)"
            >
            </kendo-slider>
            <kendo-slider
                *ngIf="opacity"
                #alphaSlider
                class="k-transparency-slider k-alpha-slider"
                [disabled]="disabled"
                [readonly]="readonly"
                [showButtons]="false"
                [tickPlacement]="'none'"
                [vertical]="true"
                [min]="0"
                [max]="100"
                [smallStep]="1"
                [largeStep]="10"
                [value]="alphaSliderValue"
                (valueChange)="handleAlphaSliderChange($event)"
            >
            </kendo-slider>
        </div>
        <kendo-colorinput
            [opacity]="opacity"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
        >
        </kendo-colorinput>
`
            },] },
];
/** @nocollapse */
ColorGradientComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: Renderer2, },
    { type: ChangeDetectorRef, },
];
ColorGradientComponent.propDecorators = {
    'hostClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-flatcolorpicker',] },],
    'disabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
    'hostTabindex': [{ type: HostBinding, args: ['attr.tabindex',] },],
    'opacity': [{ type: Input },],
    'disabled': [{ type: Input },],
    'readonly': [{ type: Input },],
    'value': [{ type: Input },],
    'tabindex': [{ type: Input },],
    'valueChange': [{ type: Output },],
    'alphaSlider': [{ type: ViewChild, args: ['alphaSlider',] },],
    'gradientWrapper': [{ type: ViewChild, args: ['gradientWrapper',] },],
    'dragHandle': [{ type: ViewChild, args: ['dragHandle',] },],
};
